### [OpenProcess function](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess) (processthreadsapi.h)

Opens an existing local process object.

Syntax (C++):
HANDLE OpenProcess(
  DWORD dwDesiredAccess,
  BOOL  bInheritHandle,
  DWORD dwProcessId
);

Parameters
*dwDesiredAccess*

The access to the process object. This access right is checked against the security descriptor for the process. This parameter can be one or more of the process access rights.

If the caller has enabled the SeDebugPrivilege privilege, the requested access is granted regardless of the contents of the security descriptor.

*bInheritHandle*

If this value is TRUE, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.

*dwProcessId*

The identifier of the local process to be opened


Remarks
To open a handle to another local process and obtain full access rights, you must enable the SeDebugPrivilege privilege.

The handle returned by the OpenProcess function can be used in any function that requires a handle to a process.

If the function succeeds, the return value is an open handle to the specified process.

If the function fails, the return value is NULL.

When you are finished with the handle, be sure to close it using the CloseHandle function.


### [VirtualAllocEx function](https://docs.microsoft.com/es-es/windows/win32/api/memoryapi/nf-memoryapi-virtualallocex) (memoryapi.h)
Reserves, commits, or changes the state of a region of memory within the virtual address space of a specified process. The function initializes the memory it allocates to zero.

Syntax (C++):
LPVOID VirtualAllocEx(
  HANDLE hProcess,
  LPVOID lpAddress,
  SIZE_T dwSize,
  DWORD  flAllocationType,
  DWORD  flProtect
);

Parameters
*hProcess*

The handle to a process. The function allocates memory within the virtual address space of this process.

The handle must have the PROCESS_VM_OPERATION access right. For more information, see Process Security and Access Rights.

*lpAddress*

The pointer that specifies a desired starting address for the region of pages that you want to allocate.

If you are reserving memory, the function rounds this address down to the nearest multiple of the allocation granularity.

If you are committing memory that is already reserved, the function rounds this address down to the nearest page boundary. To determine the size of a page and the allocation granularity on the host computer, use the GetSystemInfo function.

If lpAddress is NULL, the function determines where to allocate the region.

If this address is within an enclave that you have not initialized by calling InitializeEnclave, VirtualAllocEx allocates a page of zeros for the enclave at that address. The page must be previously uncommitted, and will not be measured with the EEXTEND instruction of the Intel Software Guard Extensions programming model.

If the address in within an enclave that you initialized, then the allocation operation fails with the ERROR_INVALID_ADDRESS error.

*dwSize*

The size of the region of memory to allocate, in bytes.

If lpAddress is NULL, the function rounds dwSize up to the next page boundary.

If lpAddress is not NULL, the function allocates all pages that contain one or more bytes in the range from lpAddress to lpAddress+dwSize. This means, for example, that a 2-byte range that straddles a page boundary causes the function to allocate both pages.

*flAllocationType*

The type of memory allocation. This parameter must contain one of the following values.

Remarks
If the function succeeds, the return value is the base address of the allocated region of pages.

If the function fails, the return value is NULL.

Each page has an associated page state. The VirtualAllocEx function can perform the following operations:

Commit a region of reserved pages

Reserve a region of free pages

Simultaneously reserve and commit a region of free pages

### [VirtualAlloc  function](https://docs.microsoft.com/es-es/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc) (memoryapi.h)
Reserves, commits, or changes the state of a region of pages in the virtual address space of the calling process. Memory allocated by this function is automatically initialized to zero.

To allocate memory in the address space of another process, use the VirtualAllocEx function.

Syntax(C++):
LPVOID VirtualAlloc(
  LPVOID lpAddress,
  SIZE_T dwSize,
  DWORD  flAllocationType,
  DWORD  flProtect
);

Parameters
*lpAddress*

The starting address of the region to allocate. If the memory is being reserved, the specified address is rounded down to the nearest multiple of the allocation granularity. If the memory is already reserved and is being committed, the address is rounded down to the next page boundary. To determine the size of a page and the allocation granularity on the host computer, use the GetSystemInfo function. If this parameter is NULL, the system determines where to allocate the region.

If this address is within an enclave that you have not initialized by calling InitializeEnclave, VirtualAlloc allocates a page of zeros for the enclave at that address. The page must be previously uncommitted, and will not be measured with the EEXTEND instruction of the Intel Software Guard Extensions programming model.

If the address in within an enclave that you initialized, then the allocation operation fails with the ERROR_INVALID_ADDRESS error.

*dwSize*

The size of the region, in bytes. If the lpAddress parameter is NULL, this value is rounded up to the next page boundary. Otherwise, the allocated pages include all pages containing one or more bytes in the range from lpAddress to lpAddress+dwSize. This means that a 2-byte range straddling a page boundary causes both pages to be included in the allocated region.

*flAllocationType*

The type of memory allocation. This parameter must contain one of the following values.

*flProtect*

The memory protection for the region of pages to be allocated. If the pages are being committed, you can specify any one of the memory protection constants.

If lpAddress specifies an address within an enclave, flProtect cannot be any of the following values:

PAGE_NOACCESS
PAGE_GUARD
PAGE_NOCACHE
PAGE_WRITECOMBINE

Remarks
If the function succeeds, the return value is the base address of the allocated region of pages.

If the function fails, the return value is NULL. 

Each page has an associated page state. The VirtualAlloc function can perform the following operations:

Commit a region of reserved pages

Reserve a region of free pages

Simultaneously reserve and commit a region of free pages

### [CreateRemoteThread function](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createremotethread) (processthreadsapi.h)
Creates a thread that runs in the virtual address space of another process.

Use the CreateRemoteThreadEx function to create a thread that runs in the virtual address space of another process and optionally specify extended attributes.

Syntax(C++):
HANDLE CreateRemoteThread(
  HANDLE                 hProcess,
  LPSECURITY_ATTRIBUTES  lpThreadAttributes,
  SIZE_T                 dwStackSize,
  LPTHREAD_START_ROUTINE lpStartAddress,
  LPVOID                 lpParameter,
  DWORD                  dwCreationFlags,
  LPDWORD                lpThreadId
);

Parameters
*hProcess*

A handle to the process in which the thread is to be created. The handle must have the PROCESS_CREATE_THREAD, PROCESS_QUERY_INFORMATION, PROCESS_VM_OPERATION, PROCESS_VM_WRITE, and PROCESS_VM_READ access rights, and may fail without these rights on certain platforms. For more information, see Process Security and Access Rights.

*lpThreadAttributes*

A pointer to a SECURITY_ATTRIBUTES structure that specifies a security descriptor for the new thread and determines whether child processes can inherit the returned handle. If lpThreadAttributes is NULL, the thread gets a default security descriptor and the handle cannot be inherited. The access control lists (ACL) in the default security descriptor for a thread come from the primary token of the creator.

Windows XP:  The ACLs in the default security descriptor for a thread come from the primary or impersonation token of the creator. This behavior changed with Windows XP with SP2 and Windows Server 2003.

*dwStackSize*

The initial size of the stack, in bytes. The system rounds this value to the nearest page. If this parameter is 0 (zero), the new thread uses the default size for the executable. For more information, see Thread Stack Size.

*lpStartAddress*

A pointer to the application-defined function of type LPTHREAD_START_ROUTINE to be executed by the thread and represents the starting address of the thread in the remote process. The function must exist in the remote process. For more information, see ThreadProc.

*lpParameter*

A pointer to a variable to be passed to the thread function.

*dwCreationFlags*

The flags that control the creation of the thread.

*lpThreadId*

A pointer to a variable that receives the thread identifier.

If this parameter is NULL, the thread identifier is not returned.

Remarks
If the function succeeds, the return value is a handle to the new thread.

If the function fails, the return value is NULL.

The CreateRemoteThread function causes a new thread of execution to begin in the address space of the specified process. The thread has access to all objects that the process opens.
